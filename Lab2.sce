// Случайный процесс ξ(t) задан как функция некоторых независимых случайных величин A и φ, а также детерминированного параметра t:
// ξ(t) = A*sin(ω*t+φ).
// Здесь параметр ω полагается детерминированным действительным числом.
//
// 1. Смоделировать и изобразить на графике несколько реализаций случайного процесса ξ(t), проведя дискретизацию параметра t.
//
// 2. Найти математическое ожидание случайного процесса ξ(t).
// Выяснить, является ли случайный процесс ξ(t) эргодическим относительно математического ожидания.
//
// 3. Построить график зависимости статистической оценки математического ожидания случайного процесса ξ(t), вычисленной по одной реализации этого случайного процесса, от длины этой реализации. 
// Сравнить её с реальным математическим ожиданием случайного процесса ξ(t).
//
// ξ(t) = A*sin(ω*t+φ).

experiments_number = 1000;
n = 2000;					// количество шагов
samples_number = 3;			//количество реализаций
step = 0.1;

left = -1.5;
right = +1.5;
omega = 3.0;

// задание случайного процесса:
function z = ksi(t,a,omega,phi)
    z = a * sin (omega * t + phi); //случайный процесс
endfunction

// получить реализацию от left до right включительно с длиной шага (left - right / n):
function [t,z] = get_realization(a, omega, phi, left, right)    // возвращает t и z
    t = [left : (right-left) / n : right];                      // задаётся одномерный массив (ОМ) t
    z = zeros(length(t), 1);                                    // создание ОМ z длины ОМ t заполненого нулям
    for k = 1 : length(t)
        z(k) = ksi (t(k), a, omega, phi);                       // заполнение ОМ z реализациями
    end
endfunction

//равномерное распределение:
function phi = uniform_distribution(left, right)
    phi = rand() * (right - left) + left; //задаем равномерное распределение для случайной величины phi
endfunction

function A = triangle_distribution()
 a = -0.5;
 b = 0.5;
 c = 0;
 U = rand();
 
 if (U < 0.5) then
     A = a + sqrt(U*(b-a)*(c-a));
 else
     A = b - sqrt((1-U)*(b-a)*(b-c));
 end
endfunction

// 1. Смоделировать и изобразить на графике несколько реализаций случайного процесса ξ(t), проведя дискретизацию параметра t.
// построение графиков реализаций СП в количестве number
function plot_realizations(number)
    scf();
    for k = 1 : number
        a = triangle_distribution();
        phi = uniform_distribution(left, right);
        [t,z] = get_realization(a, omega, phi, left, right)
        plot2d(t,z)
    end
endfunction

// 3. Построить график зависимости статистической оценки математического ожидания случайного процесса ξ(t), 
// вычисленной по одной реализации этого случайного процесса, от длины этой реализации. 
// Сравнить её с реальным математическим ожиданием случайного процесса ξ(t).
function plot_mean(n)
    scf();
    t = 0.0 : step : step * n;						// вектор t, в котором хранятся значение координат шага
    s = zeros(1, length(t));
    for k = 1 : length(t),
        a = triangle_distribution();
        phi = uniform_distribution(left, right);
        for j = 1 : k,
            s(k) = s(k) + ksi(t(j), a, omega, phi);	// для конкретного времени t берём количество реализаций k и суммируем их
        end
        s(k) = s(k) / k;							// и делим эту сумму на количество -- получаем статистическую оценку для конкретного времени t
    end // и так далее для всех остальных t
    plot2d(t, s);
    plot2d(t, zeros(1, length(t)), style = color('blue'), leg="теоретическое математическое ожидание");
endfunction

plot_realizations(samples_number);	// samples_number -- сколько графиков СП будет изображено
plot_mean(n);
